#  Java JUC
> #### PS:待开发中。。。。
> #### 作者网页：[www.jcohy.com](http://www.jcohy.com)  	

>  我的学习笔记，记录学习过程中的笔记以及遇到的问题,以及我的一些经验总结。如果出现链接失效,或者想知道更多的内容等情况可以提交 Issues 提醒我修改相关内容。

## Java JUC
> * [Java NIO简介](#gaishu)
> *  [volatile关键字](#qubie)
> *  [CAS算法](#buffer)
> *  [ConcurrentHashMap 锁分段机制](#blocking)
> *  [CountDownLatch 闭锁)](#pipe)
> *  [实现Callable 接口](#nio2)


#### Java NIO简介
在Java 5.0 提供了java.util.concurrent（简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的Collection 实现等。

#### volatile关键字

在了解volatile关键之前，我们先了解几个概念：

> 内存可见性（Memory Visibility）：是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。

> 可见性错误：是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。

##### volatile的定义
java语言规范第三版中对volatile的定义：Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。java语言提供了volatile，在某些情况下比锁更加方便，而且他不会引起线程 上下文的切换和调度。
如果一个字段被声明成volatile,java内存模型确保所有线程看到这个变量的值是一致的。

volatile 看做一个轻量级的锁，但是又与锁有些不同：

> * 对于多线程，不是一种互斥关系
> * 不能保证变量状态的“原子性操作”，例如i++

#### volatile如何保证可见性



