#  计算机网络

> #### PS:待开发中。。。。
> #### 作者网页：[www.jcohy.com](http://www.jcohy.com)  	

>  我的学习笔记，记录学习过程中的笔记以及遇到的问题,以及我的一些经验总结。如果出现链接失效,或者想知道更多的内容等情况可以提交 Issues 提醒我修改相关内容。

## 计算机网络
> * [停止等待协议](#network-1)
> * [滑动窗口协议](#network-2)
> * [Http1.0和Http1.1的区别](#network-3)
> * [Post和Get的区别](#network-4)
> * [TCP/IP体系各层功能及协议](#network-5)
> * [TCP的三次握手和四次挥手的过程](#network-6)
> * [为什么连接建立是三次握手，而连接释放要四次挥手？](#network-7)
> * [为什么TIME_WAIT状态需要2MSL（最大报文段生存时间）才能返回Closed状态？](#network-8)
> * [Http报文格式](#network-9)
> * [Http和Https的区别](#network-10)
> * [浏览器输入一个URL的过程](#network-11)
> * [中间人攻击](#network-12)
> * [差错检测](#network-13)
> * [数据链路层的协议](#network-14)
> * [截断二进制指数退避算法](#network-15)


<p id="network-1">

#### 停止等待协议

停止等待协议是最基本的数据链路层协议，它的工作原理是这样的。

在发送端，每发送完一帧就停止发送，等待接收端的确认，如果收到确认就发送下一帧。

在接收端，每收到一个无差错的帧，就把这个帧交付上层并向发送端发送确认。若该帧有差错，就丢弃，其他什么也不做。

其他细节：

停止等待协议为了可靠交付，需要对帧进行编号，由于每次只发送一帧，所以停止等待协议使用1个比特编号，编号0和1

停止等待协议会出现死锁现象（A等待B的确认），解决办法，启动超时计时器，超时计时器有一个重传时间。重传时间一般选择略大于“正常情况下从发完数据帧到收到确认帧所需的平均时间”。

<p id="network-2">

#### 滑动窗口协议

再说滑动窗口之前，先说下连续ARQ，连续ARQ又称Go-back-N ARQ，意思是当出现差错必须重传时，要向回走N个帧，然后再开始重传，也就意味着只要有一帧出现差错，即使已经正确的帧也需要重传，白白浪费时间，增大开销。为此，应该对发送出去但未被确认的帧的数目加以限制，这就是滑动窗口协议。滑动窗口指收发两端分别维护一个发送窗口和接收窗口，发送窗口有一个窗口值Wt，窗口值Wt代表在没有收到对方确认的情况下最多可以发送的帧的数目。当发送的帧的序号被接收窗口正确收下后，接收端向前滑动并向发送端发去确认，发送端收到确认后，发送窗口向前滑动。收发两端按规律向前推进。

连续ARQ和选择重传ARQ均是窗口大于1的滑动窗口协议，而停止等待协议相当于收发两端窗口等于1。

滑动窗口指接收和发送两端的窗口按规律不断向前推进，是一种流量控制的策略。

<p id="network-3">

#### Http1.0和Http1.1的区别

1.HTTP/1.0协议使用非持久连接,即在非持久连接下,一个tcp连接只传输一个Web对象。
2.HTTP/1.1默认使用持久连接(然而,HTTP/1.1协议的客户机和服务器可以配置成使用非持久连接)。在持久连接下,不必为每个Web对象的传送建立一个新的连接,一个连接中可以传输多个对象。

<p id="network-4">

#### Post和Get的区别

1.安全性上说：get的方式是把数据在地址栏中明文的形式发送，URL中可见，POST方式对用户是透明的，安全性更高。
2.数据量说：Get传送的数据量较小，一般不能大于2KB，POST传送的数据量更大。
3.适用范围说：查询用Get，数据添加、修改和删除建议Post

<p id="network-5">

#### TCP/IP体系各层功能及协议

TCP/IP体系共有四个层次，分别为网络接口层Host-to-Network Layer, 网际层 Internet Layer， 传输层Transport Layer，应用层Application Layer。

5.1 **网络接口层** -> 接收和发送数据报

主要负责将数据发送到网络传输介质上以及从网络上接收TCP/IP数据报，相当于OSI参考模型的物理层和数据链路层。在实际中，先后流行的以太网、令牌环网、ATM、帧中继等都可视为其底层协议。它将发送的信息组装成帧并通过物理层向选定网络发送，或者从网络上接收物理帧，将去除控制信息后的IP数据报交给网络层。

5.2 **网际层** -> 数据报封装和路由寻址

网际层主要功能是寻址和对数据报的封装以及路由选择功能。这些功能大部分通过IP协议完成，并通过地址解析协议ARP、逆地址解析协议RARP、因特网控制报文协议ICMP、因特网组管理协议IGMP从旁协助。所以IP协议是网络层的核心。

网际协议IP：IP协议是一个无连接的协议，主要负责将数据报从源结点转发到目的结点。也就是说IP协议通过对数据报中源地址和目的地址进行分析，然后进行路由选择，最后再转发到目的地。需要注意的是：IP协议只负责对数据进行转发，并不对数据进行检查，也就是说，它不负责数据的可靠性，这样设计的主要目的是提高IP协议传送和转发数据的效率。

ARP：该协议负责将IP地址解析转换为计算机的物理地址。

虽然我们使用IP地址进行通信，但IP地址只是主机在抽象的网络层中的地址。最终要传到数据链路层封装成MAC帧才能发送到实际的网络。因此不管使用什么协议最终需要的还是硬件地址。

每个主机拥有一个ARP高速缓存（存放所在局域网内主机和路由器的IP地址到硬件地址的映射表）

举例：A发送B

(1)A在自己的ARP高速缓存中查到B的MAC地址，写入MAC帧发往此B

(2)没查到，A向本局域网广播ARP请求分组，内容包括自己的地址映射和B的IP地址

(3)B发送ARP响应分组，内容为自己的IP地址到物理地址的映射，同时将A的映射写入自己的ARP高速缓存（单播的方式）

注：ARP Cache映射项目具有一个生存时间。

RARP：将计算机物理地址转换为IP地址

ICMP：该协议主要负责发送和传递包含控制信息的数据报，这些控制信息包括了哪台计算机出现了什么错误，网络路由出现了什么错误等内容。

5.3 **传输层** -> 应用进程间端到端的通信

传输层主要负责应用进程间“端到端”的通信，即从某个应用进程传输到另一个应用进程，它与OSI参考模型的传输层功能类似。

传输层在某个时刻可能要同时为多个不同的应用进程服务，因此传输层在每个分组中必须增加用于识别应用进程的标识，即端口。

TCP/IP体系的传输层主要包含两个主要协议，即传输控制协议TCP和用户数据报协议UDP。TCP协议是一种可靠的、面向连接的协议，保证收发两端有可靠的字节流传输，进行了流量控制，协调双方的发送和接收速度，达到正确传输的目的。

UDP是一种不可靠的、无连接的协议，其特点是协议简单、额外开销小、效率较高，不能保证可靠传输。

传输层提供应用进程间的逻辑通信。它使应用进程看见的就好像是在两个运输层实体间一条端到端的逻辑通信信道。

当运输层采用TCP时，尽管下面的网络是不可靠的，但这种逻辑通信信道相当于一条全双工的可靠信道。可以做到报文的无差错、按序、无丢失、无重复。

注：单单面向连接只是可靠的必要条件，不充分。还需要其他措施，如确认重传，按序接收，无丢失无重复。

熟知端口：

```
20 FTP数据连接 
21 FTP控制连接 
22 SSH 
23 TELNET 
25 SMTP 
53 DNS 
69 TFTP
80 HTTP
161 SNMP
```

**UDP**重要

UDP的优点：

1.发送之前无需建立连接，减小了开销和发送数据的时延

2.UDP不使用连接，不使用可靠交付，因此主机不需要维护复杂的参数表、连接状态表

3.UDP用户数据报只有8个字节的首部开销，而TCP要20字节。

4.由于没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（IP电话等实时应用要求源主机以恒定的速率发送数据是有利的）

Table，使用TCP和UDP的应用

应用           |    应用层协议    |    运输层协议
-------------- |    ------------  |    ---------
名字转换       |       DNS        |      UDP
文件传送       |       TFTP       |      UDP
路由选择协议   |       RIP        |      UDP
IP地址配置     |   BOOTTP,DHCP    |      UDP
网络管理       |      SNMP        |      UDP
远程文件服务器 |      NFS         |      UDP
IP电话         |      专用协议    |      UDP
流式多媒体通信 |      专用协议    |      UDP
电子邮件       |      SMTP        |      TCP
远程终端接入   |      TELNET      |      TCP
万维网         |      HTTP        |      TCP
文件传送       |      FTP         |      TCP

注：TFTP：Trivial File Transfer Protocol

UDP的过程（以TFTP举例）：

1.服务器进程运行着，等待TFTP客户进程的服务请求。客户端TFTP进程启动时，向操作系统申请一个临时端口号，然后操作系统为该进程创建2个队列，
入队列和出队列。只要进程在执行，2个队列一直存在。

2.客户进程将报文发送到出队列中。UDP按报文在队列的先后顺序发送。在传送到IP层之前给报文加上UDP首部，其中目的端口后为69，然后发给IP层。
出队列若溢出，则操作系统通知应用层TFTP客户进程暂停发送。

3.客户端收到来自IP层的报文时，UDP检查报文中目的端口号是否正确，若正确，放入入队列队尾，客户进程按先后顺序一一取走。若不正确，UDP丢弃该报文，并请ICMP发送”端口不可达“差错报文给服务器端。入队列可能会溢出，若溢出，UDP丢弃该报文，不通知对方。

服务器端类似。

UDP首部：源端口 - 目的端口 - 长度 - 检验和，每个字段22字节。

注：IP数据报检验和只检验IP数据报的首部，而UDP的检验和将首部和数据部分一起都检验。

**TCP重要**

细节：

TCP报文段是面向字节的数据流。

TCP首部：20字节固定首部

确认比特ACK，ACK=1 确认号字段才有效；同步比特SYN：SYN=1 ACK=0表示一个连接请求报文段；终止比特FIN，FIN=1时要求释放连接。

窗口：将TCP收发两端记为A和B，A根据TCP缓存空间的大小确定自己的接收窗口大小。并在A发送给B的窗口字段写入该值。作为B的发送窗口的上限。意味着B在未收到A的确认情况下，最多发送的字节数。

选项：最大报文段长度MSS，MSS告诉对方TCP：我的缓存所能接收的报文段的数据字段的最大长度是MSS个字节。若主机未填写，默认为536字节。

TCP的可靠是使用了序号和确认。当TCP发送一个报文时，在自己的重传队列中存放一个副本。若收到确认，删除副本。

TCP使用捎带确认。

TCP报文段的发送时机：1.维持一个变量等于MSS，发送缓存达到MSS就发送 2.发送端应用进程指明要发送，即TCP支持的PUSH操作。3.设定计时器

**TCP的拥塞控制：TCP使用慢开始和拥塞避免算法进行拥塞控制**

**慢开始和拥塞避免**

接收端根据自身资源情况控制发送端发送窗口的大小。

每个TCP连接需要维持一下2个状态变量：

接收端窗口rwnd（receiver window）：接收端根据目前接收缓存大小设置的窗口值，是来自接收端的流量控制

拥塞窗口cwnd（congestion window）：是发送端根据自己估计的网络拥塞程度设置的窗口值，是来自发送端的流量控制

发送端的窗口上限值=Min(rwnd, cwnd)

慢开始算法原理：主机刚开始发送数据时，如果立即将较大的发送窗口的全部字节注入网络，由于不清楚网络状况，可能会引起拥塞。通常的做法是将cwnd设置为1个MSS，每收到一个确认，将cwnd+1，由小到大逐步增大cwnd，使分组注入网络的速率更加合理。为了防止拥塞窗口增长引起网络拥塞，还需设置一个状态变量ssthresh，即慢开始门限。

慢开始门限：ssthresh，当cwnd < ssthresh,执行慢开始算法；cwnd > ssthresh，改用拥塞避免算法。 cwnd = ssthresh时，都可以。

拥塞避免算法使发送端的拥塞窗口每经过一个RTT增加一个MSS（而不管在此期间收到多少ACK），这样，拥塞窗口cwnd按线性规律增长，拥塞窗口此时比慢开始增长速率缓慢很多。这一过程称为加法增大，目的在于使拥塞窗口缓慢增长，防止网络过早拥塞。

无论是慢开始还是拥塞避免，只要发送端发现网络出现拥塞（根据是没有按时收到ACK或者收到重复ACK），就将慢开始门限ssthresh设置为拥塞窗口值的一半并将拥塞窗口cwnd置为1，重新执行慢开始算法。这一过程称为乘法减小。目的在于迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

上述TCP确认都是通过捎带确认执行的。

**快重传和快恢复**

上述的慢开始和拥塞避免算法是早期TCP使用的拥塞控制算法。因为有时TCP连接会在重传时因等待重传计时器的超时时间而空闲。为此在快重传中规定：只要发送端一连收到三个重复的ACK,即可断定分组丢失，不必等待重传计数器，立即重传丢失的报文。

与快重传搭配使用的还有快恢复：当不使用快恢复时，发送端若发现网络拥塞就将拥塞窗口降为1，然后执行慢开始算法，这样的缺点是网络不能很快恢复到正常状态。快恢复是指当发送端收到3个重复的ACK时，执行乘法减小，ssthresh变为拥塞窗口值的一半。但是cwnd不是置为1，而是ssthresh+3xMSS。若收到的重复ACK
为n(n > 3)，则cwnd=ssthresh+n*MSS.这样做的理由是基于发送端已经收到3个重复的ACK，它表明已经有3个分组离开了网络，它们不在消耗网络的资源。

注意的是：在使用快恢复算法时，慢开始算法只在TCP连接建立时使用。

TCP的重传机制

每发送一个报文段，就对这个报文段设置一次计时器。新的重传时间=γ*旧的重传时间。

**TCP连接建立和释放的过程**

SYN置1和FIN的报文段要消耗一个序号。

客户端连接状态变迁：CLOSED -> 主动打开,发送SYN=1 -> SYN_SENT -> 收到服务器的SYN=1和ACK时,发送三次握手的最后一个ACK 
-> ESTABLISHED -> 数据传送 -> 主动关闭 -> 发送FIN=1,等待确认ACK的到达 -> FIN_WAIT_1 -> 收到确认ACK后 -> FIN_WAIT_2
-> 收到服务器发送的FIN=1报文，响应，发送四次挥手的的最后一个确认ACK -> 进入TIME_WAIT状态 
-> 经过2倍报文寿命，TCP删除连接记录 -> 回到CLOSED状态 

客户端状态：CLOSED - SYN_SENT- ESTABLISHED - FIN_WAIT_1 - FIN_WAIT_2 - TIME_WAIT - CLOSED

服务器端连接状态变迁：CLOSED -> 被动打开 -> LISTEN -> 收到SYN=1的报文，发送SYN=1和确认ACK -> 进入SYN_RCVD -> 收到三次握手
的最后一个确认ACK -> ESTABLISHED -> 数据传送 -> 数据传送完毕，收到FIN=1 -> 发送确认ACK并进入CLOSED_WAIT -> 发送FIN=1给客户端 -> LAST_ACK 
-> 收到客户端四次挥手的最后一个确认ACK -> 删除连接记录 -> 回到CLOSED状态

服务器端：CLOSED - LISTEN - SYN_RCVD - ESTABLISHED - CLOSED_WAIT - LAST_ACK - CLOSED 

5.4 **应用层**

应用层位于TCP/IP体系结构的最高一层，也是直接为应用进程服务的一层，即当不同的应用进程数据交换时，就去调用应用层的不同协议实体，让这些实体去调用传输层的TCP或者UDP来进行网络传输。具体的应用层协议有，SMTP 25、DNS 53、HTTP 80、FTP 20数据端口 21控制端口、TFTP 69、TELNET 23、SNMP 161等

5.5 网络的划分 

按网络拓扑结构：总线、星型、环型、树型、网状结构和混合型。

按覆盖范围：局域网、城域网、广域网

按传播方式：广播网络和点对点网络

广播式网络是指网络中的计算机使用一个共享信道进行数据传播，网络中的所有结点都能收到某一结点发出的数据信息。

单播：一对一的发送形式。

组播：采用一对一组的发送形式，将数据发送给网络中的某一组主机。

广播：采用一对所有，将数据发送给网络所有目的结点。

点对点网络中两个结点间的通信方式是点对点的。如果两台计算机之间没有直连的线路，则需要中间结点的接收、存储、转发直至目的结点。

<p id="network-6">

#### TCP的三次握手和四次挥手的过程

以客户端为例

连接建立（三次握手）：首先Client端发送连接请求报文SYN并进入SYN_SENT状态，Server收到后发送ACK+SYN报文，并为这次连接分配资源。Client端接收到Server端的SYN+ACK后发送三次握手的最后一个ACK，并分配资源，连接建立。

连接释放（四次挥手）：假设Client端发起断开连接请求，首先发送FIN=1,等待确认ACK的到达 

-> FIN_WAIT_1 

-> 收到Server端的确认ACK后时 -> FIN_WAIT_2
-> 收到服务器发送的FIN=1报文，响应，发送四次挥手的的最后一个确认ACK ->进入TIME_WAIT状态 
-> 经过2倍报文寿命，TCP删除连接记录 -> 回到CLOSED状态

<p id="network-7">

#### 为什么连接建立是三次握手，而连接释放要四次挥手？

因为当Server端收到Client端发送的SYN连接请求报文后，可以直接发送SYN+ACK报文，其中ACK用来应答，SYN用来同步。但是关闭连接时，当Server端收到FIN报文后，并不会立即关闭socket，所以先回复一个ACK，告诉Client端“你的FIN我收到了”，只有等Server端的所有报文发送完了，Server端才发送FIN报文，因此不能一起发送，故需要四次挥手。

<p id="network-8">

#### 为什么TIME_WAIT状态需要2MSL（最大报文段生存时间）才能返回Closed状态？

这是因为虽然双方都同意关闭连接了，而且四次挥手的报文也都协调发送完毕。但是我们必须假想网络是不可靠的，无法保证最后发送的ACK报文一定被对方收到，因此处于LAST_ACK状态下的
Server端可能会因未收到ACK而重发FIN，所以TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。

<p id="network-9">

#### Http报文格式

Http请求报文格式：1.请求行 2.Http头 3.报文主体

请求行由三部分组成，分别是请求方法，请求地址，Http版本

Http头：有三种，分别为请求头（request header），普通头（General Header）和实体头（entity header）。

Get方法没有实体头。

报文主体：只在POST方法请求中存在。

Http响应报文：1.状态行 2.Http头 3.返回内容

状态行：第一部分为Http版本，第二部分为响应状态码 第三部分为状态码的描述

其中第三部分为状态码的描述，信息类100-199 响应成功200-299 重定向类300-399 客户端错误400-499 服务器端错误500-599

常见的

```
100 continue 初始请求已接受，客户端应继续发送请求剩余部分
200 OK
202 Accepted 已接受，处理尚未完成 
301 永久重定向
302 临时重定向
400 Bad Request
401 Unauthorized
403 Forbidden 资源不可用
404 Not Found
500 Internal Server Error 服务器错误
502 Bad Gateway
503 Service Unavailable 服务器负载过重
504 Gateway Timeout 未能及时从远程服务器获得应答
```

Http头：响应头（Response Header），普通头（General Header）和实体头(Entity Header)

返回内容：即Http请求的信息，可以是HTML也可以是图片等等。

<p id="network-10">

#### Http和Https的区别

Https即Secure Hypertext Transfer Protocol，即安全超文本传输协议，它是一个安全通信信道，基于Http开发，用于在客户机和服务器间交换信息。它使用安全套接字层SSL进行信息交换，是Http的安全版。

Https协议需要到CA申请证书，一般免费证书很少，需要交费。

Http是超文本传输协议，信息是明文传输，https则是具有安全性的tls/ssl加密传输协议。

http是80端口，https是443端口

<p id="network-11">

#### 浏览器输入一个URL的过程

1. 浏览器向DNS服务器请求解析该URL中的域名所对应的IP地址

2. 解析出IP地址后，根据IP地址和默认端口80和服务器建立TCP连接

3. 浏览器发出Http请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器

4. 服务器做出响应，把对应的请求资源发送给浏览器

5. 释放TCP连接

6. 浏览器解析并显示内容

<p id="network-12">

#### 中间人攻击

中间人获取server发给client的公钥，自己伪造一对公私钥，然后伪造自己让client以为它是server，然后将伪造的公钥发给client，并拦截client发给server的密文，用伪造的私钥即可得到client发出去的内容，最后用真实的公钥对内容加密发给server。

解决办法：数字证书，证书链，可信任的中间人

<p id="network-13">

####  差错检测

误码率：传输错误的比特与传输总比特数的比率

CRC是检错方法并不能纠错，FCS（Frame Check Sequence）是冗余码。

计算冗余码（余数R）的方法：先补0（n个）再对生成多项式取模。

CRC只能表示以接近1的概率认为它没有差错。但不能做到可靠传输。可靠传输还需要确认和重传机制。

生成多项式P(X)：CRC-16，CRC-CCITT，CRC-32

<p id="network-14">

####  数据链路层的协议

停止等待协议 - 连续ARQ - 选择重传ARQ - PPP - 以太网协议- 帧中继 - ATM - HDLC

<p id="network-15">

####  截断二进制指数退避算法

是以太网用于解决当发生碰撞时就停止发送然后重发再碰撞这一问题。

截断二进制指数退避算法：基本退避时间为2τ k=min{重传次数，10} r=random(0~2^k-1) 重传所需时延为r倍的基本退避时间
