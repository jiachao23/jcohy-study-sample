#### 构造SpringApplication对象，调用initialize()方法

当Springboot启动后，首先调用run方法。构造一个SpringApplication对象，使用默认设置和用户提供的参数加载配置。如下：

```java
/**
 * Static helper that can be used to run a {@link SpringApplication} from the
 * specified sources using default settings and user supplied arguments.
 * @param sources the sources to load
 * @param args the application arguments (usually passed from a Java main method)
 * @return the running {@link ApplicationContext}
 */
public static ConfigurableApplicationContext run(Object[] sources, String[] args) {
   return new SpringApplication(sources).run(args);
}
```

```java
public SpringApplication(Object... sources) {
   initialize(sources);
}
```

#### 我们主要看分析**initialize()**方法都做了那些事？

```java
private void initialize(Object[] sources) {
    //初始化source（此为我们传进去的参数）
   if (sources != null && sources.length > 0) {
      this.sources.addAll(Arrays.asList(sources));
   }
    /**
	 * 判断是否为web环境。
	 * 是通过在classpath中查看是否存在WEB_ENVIRONMENT_CLASSES这个数组中所包含的类，如果存在那么当前程序即是一个Web应用程序，反之则不然。
	 * 	private static final String[] WEB_ENVIRONMENT_CLASSES = { "javax.servlet.Servlet",
			"org.springframework.web.context.ConfigurableWebApplicationContext" };
	 */
   this.webEnvironment = deduceWebEnvironment();
    //为成员变量initializers赋值，//加载工厂实现的完全限定类名，从META-INF/spring.factories文件中加载key为org.springframework.context.ApplicationContextInitializer的工厂类名，并创建实例
   setInitializers((Collection) getSpringFactoriesInstances(
         ApplicationContextInitializer.class));
    ////为成员变量listeners赋值，加载工厂实现的完全限定类名，从META-INF/spring.factories文件中加载key为org.springframework.context.ApplicationListener的工厂类名，并创建实例
   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
   this.mainApplicationClass = deduceMainApplicationClass();
}
```

1、配置source。

2、判断是否是web环境。

```java

private static final String[] WEB_ENVIRONMENT_CLASSES = { "javax.servlet.Servlet",
			"org.springframework.web.context.ConfigurableWebApplicationContext" };
private boolean deduceWebEnvironment() {
   for (String className : WEB_ENVIRONMENT_CLASSES) {
      if (!ClassUtils.isPresent(className, null)) {
         return false;
      }
   }
   return true;
}
```

3、查找并加载所有可用的 ApplicationContextInitializer，initializers成员变量，是一个ApplicationContextInitializer类型对象的集合。 顾名思义，ApplicationContextInitializer是一个可以用来初始化ApplicationContext的接口。`getSpringFactoriesInstances` 请留意此方法，下面多出会使用到此方法。

```java
private <T> Collection<? extends T> getSpringFactoriesInstances(Class<T> type,
      Class<?>[] parameterTypes, Object... args) {
   ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
   // 防止名称重复
   Set<String> names = new LinkedHashSet<String>(
       	//加载工厂实现的完全限定类名，从META-INF/spring.factories文件中加载key为org.springframework.context.ApplicationContextInitializer的工厂类名
         SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    	//创建工厂实例
   List<T> instances = createSpringFactoriesInstances(type, parameterTypes,
         classLoader, args, names);
   AnnotationAwareOrderComparator.sort(instances);
   return instances;
}
```
我们看看 `SpringFactoriesLoader.loadFactoryNames(type, classLoader));` 中的代码：

```java
public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";

public static List<String> loadFactoryNames(Class<?> factoryClass, ClassLoader classLoader) {
    //factoryClassName = org.springframework.context.ApplicationContextInitializer
   String factoryClassName = factoryClass.getName();
   try {
      //FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories"
      Enumeration<URL> urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :
            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));
      List<String> result = new ArrayList<String>();
      while (urls.hasMoreElements()) {
         URL url = urls.nextElement();
         Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url));
         String factoryClassNames = properties.getProperty(factoryClassName);
         result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));
      }
      return result;
   }
   catch (IOException ex) {
      throw new IllegalArgumentException("Unable to load [" + factoryClass.getName() +
            "] factories from location [" + FACTORIES_RESOURCE_LOCATION + "]", ex);
   }
}
```

4、同理，查找并加载所有可用的 ApplicationListener，此类的全限定类名为 `org.springframework.context.ApplicationListener`。从`META-INF/spring.factories`文件中加载key为`org.springframework.context.ApplicationContextInitializer`的工厂类名：

```java
setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
```

5、推断并设置main方法的定义类。

```java
private Class<?> deduceMainApplicationClass() {
   try {
      StackTraceElement[] stackTrace = new RuntimeException().getStackTrace();
      for (StackTraceElement stackTraceElement : stackTrace) {
         if ("main".equals(stackTraceElement.getMethodName())) {
            return Class.forName(stackTraceElement.getClassName());
         }
      }
   }
   catch (ClassNotFoundException ex) {
      // Swallow and continue
   }
   return null;
}
```

#### 初始化完成后，开始执行run方法

```java
public ConfigurableApplicationContext run(String... args) {
    //简单的秒表，允许多个任务的计时，公开每个命名任务的总运行时间和运行时间。
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   //1、开启打印
   configureHeadlessProperty();
    //2、加载，创建SpringApplicationRunListener实例
   SpringApplicationRunListeners listeners = getRunListeners(args);
    //首次启动run方法时立即调用.
   listeners.starting();
   try {
       //3、封装命令行参数
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
       //4、环境准备，封装环境变量信息。如果为web环境，则创建StandardServletEnvironment。否则创建StandardEnvironment
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
       //5、打印banner
      Banner printedBanner = printBanner(environment);
       //6、创建上下文，org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);
       //7、刷新
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) {
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      }
      return context;
   }
   catch (Throwable ex) {
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   }
}
```

1、开启屏幕打印。

```java
private static final String SYSTEM_PROPERTY_JAVA_AWT_HEADLESS = "java.awt.headless";
private void configureHeadlessProperty() {
   System.setProperty(SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, System.getProperty(
         SYSTEM_PROPERTY_JAVA_AWT_HEADLESS, Boolean.toString(this.headless)));
}
```
2、获取启动时的监听器，当触发启动事件，相应的监听器会被调用。其加载机制原理和加载ApplicationContextInitializer与ApplicationListener原理一样。只不过它是从classpath下面查找名为`org.springframework.boot.SpringApplicationRunListener` 的类加载并实例化。

```java
private SpringApplicationRunListeners getRunListeners(String[] args) {
   Class<?>[] types = new Class<?>[] { SpringApplication.class, String[].class };
   return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(
         SpringApplicationRunListener.class, types, this, args));
}
```
这里简单说明一下，在 `META-INF/spring.factories` 文件中，只有一个此类的实现为：

```xml
org.springframework.boot.SpringApplicationRunListener=\
org.springframework.boot.context.event.EventPublishingRunListener
```
说的再简单点，getRunListeners就是准备好了运行时监听器`EventPublishingRunListener`。

当执行 `listeners.starting()` 时，我们看看发生了什么。

```java
public void starting() {
   this.initialMulticaster
         .multicastEvent(new ApplicationStartedEvent(this.application, this.args));
}
```

其构建了一个ApplicationStartingEvent事件，并将其发布出去。

```java
@Override
public void multicastEvent(final ApplicationEvent event, ResolvableType eventType) {
   ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));
    //getApplicationListeners(event, type)：根据其注释可知，该方法作用：返回与给定事件类型匹配的ApplicationListeners集合，非匹配的侦听器会被提前排除；允许根据缓存的匹配结果来返回。
   for (final ApplicationListener<?> listener : getApplicationListeners(event, type)) {
      Executor executor = getTaskExecutor();
      if (executor != null) {
         executor.execute(new Runnable() {
            @Override
            public void run() {
               invokeListener(listener, event);
            }
         });
      }
      else {
         invokeListener(listener, event);
      }
   }
}
```

`getApplicationListeners`方法过滤出的监听器都会被调用，过滤出来的监听器包括`LoggingApplicationListener、BackgroundPreinitializer、DelegatingApplicationListener、LiquibaseServiceLocatorApplicationListener、EnableEncryptablePropertiesBeanFactoryPostProcessor`五种类型的对象。当执行`invokeListener`方法时，这五个对象的onApplicationEvent都会被调用。

3、封装命令行参数

4、环境准备，如果为web环境，则创建StandardServletEnvironment。否则创建StandardEnvironment

```java
private ConfigurableEnvironment prepareEnvironment(
      SpringApplicationRunListeners listeners,
      ApplicationArguments applicationArguments) {
   // 创建并配置环境
   ConfigurableEnvironment environment = getOrCreateEnvironment();
   configureEnvironment(environment, applicationArguments.getSourceArgs());
   listeners.environmentPrepared(environment);
   if (!this.webEnvironment) {
      environment = new EnvironmentConverter(getClassLoader())
            .convertToStandardEnvironmentIfNecessary(environment);
   }
   return environment;
}
```

5、打印banner，到此为止，控制台上终于有输出了、就是打印SpringBoot默认的banner。默认从classpath：下加载名为 banner.txt 的文件。如果不存在。则打印默认banner。此实现在 `SpringBootBanner` 类中。下面贴出相关代码：

```java
private Banner printBanner(ConfigurableEnvironment environment) {
   if (this.bannerMode == Banner.Mode.OFF) {
      return null;
   }
   ResourceLoader resourceLoader = this.resourceLoader != null ? this.resourceLoader
         : new DefaultResourceLoader(getClassLoader());
   SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(
         resourceLoader, this.banner);
   if (this.bannerMode == Mode.LOG) {
      return bannerPrinter.print(environment, this.mainApplicationClass, logger);
   }
   return bannerPrinter.print(environment, this.mainApplicationClass, System.out);
}
```

```java
private Banner printBanner(ConfigurableEnvironment environment) {
   if (this.bannerMode == Banner.Mode.OFF) {
      return null;
   }
   ResourceLoader resourceLoader = this.resourceLoader != null ? this.resourceLoader
         : new DefaultResourceLoader(getClassLoader());
   SpringApplicationBannerPrinter bannerPrinter = new SpringApplicationBannerPrinter(
         resourceLoader, this.banner);
   if (this.bannerMode == Mode.LOG) {
      return bannerPrinter.print(environment, this.mainApplicationClass, logger);
   }
   return bannerPrinter.print(environment, this.mainApplicationClass, System.out);
}
```

```java
public Banner print(Environment environment, Class<?> sourceClass, Log logger) {
   Banner banner = getBanner(environment, this.fallbackBanner);
   try {
      logger.info(createStringFromBanner(banner, environment, sourceClass));
   }
   catch (UnsupportedEncodingException ex) {
      logger.warn("Failed to create String for banner", ex);
   }
   return new PrintedBanner(banner, sourceClass);
}
```

```java
private static final Banner DEFAULT_BANNER = new SpringBootBanner();

private Banner getBanner(Environment environment, Banner definedBanner) {
   Banners banners = new Banners();
   banners.addIfNotNull(getImageBanner(environment));
   banners.addIfNotNull(getTextBanner(environment));
   if (banners.hasAtLeastOneBanner()) {
      return banners;
   }
   if (this.fallbackBanner != null) {
      return this.fallbackBanner;
   }
   return DEFAULT_BANNER;
}
```

```java
class SpringBootBanner implements Banner {

   private static final String[] BANNER = { "",
         "  .   ____          _            __ _ _",
         " /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\",
         "( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\",
         " \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )",
         "  '  |____| .__|_| |_|_| |_\\__, | / / / /",
         " =========|_|==============|___/=/_/_/_/" };

   private static final String SPRING_BOOT = " :: Spring Boot :: ";

   private static final int STRAP_LINE_SIZE = 42;

   @Override
   public void printBanner(Environment environment, Class<?> sourceClass,
         PrintStream printStream) {
      for (String line : BANNER) {
         printStream.println(line);
      }
      String version = SpringBootVersion.getVersion();
      version = (version == null ? "" : " (v" + version + ")");
      String padding = "";
      while (padding.length() < STRAP_LINE_SIZE
            - (version.length() + SPRING_BOOT.length())) {
         padding += " ";
      }

      printStream.println(AnsiOutput.toString(AnsiColor.GREEN, SPRING_BOOT,
            AnsiColor.DEFAULT, padding, AnsiStyle.FAINT, version));
      printStream.println();
   }

}
```

6、创建上下文，创建FailureAnalyzers实例。在刷新之前将所有配置应用于上下文

```java
//创建上下文
public static final String DEFAULT_WEB_CONTEXT_CLASS = "org.springframework."
			+ "boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext";
protected ConfigurableApplicationContext createApplicationContext() {
   Class<?> contextClass = this.applicationContextClass;
   if (contextClass == null) {
      try {
         contextClass = Class.forName(this.webEnvironment
               ? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);
      }
      catch (ClassNotFoundException ex) {
         throw new IllegalStateException(
               "Unable create a default ApplicationContext, "
                     + "please specify an ApplicationContextClass",
               ex);
      }
   }
   return (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);
}
```

```java
/**
 * Create a new {@link AnnotationConfigEmbeddedWebApplicationContext} that needs to be
 * populated through {@link #register} calls and then manually {@linkplain #refresh
 * refreshed}.
 * 注册所有注解相关的处理器
 * 配置扫面路径下的特定注解
 */
public AnnotationConfigEmbeddedWebApplicationContext() {
   this.reader = new AnnotatedBeanDefinitionReader(this);
   this.scanner = new ClassPathBeanDefinitionScanner(this);
}
```

```java
//准备上下文
private void prepareContext(ConfigurableApplicationContext context,
    ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,
      ApplicationArguments applicationArguments, Banner printedBanner) {
    //传递环境变量
   context.setEnvironment(environment);
    //添加容器后置处理器
   postProcessApplicationContext(context);
    //应用初始化
   applyInitializers(context);
    //通知容器就绪事件
   listeners.contextPrepared(context);
   if (this.logStartupInfo) {
      logStartupInfo(context.getParent() == null);
      logStartupProfileInfo(context);
   }
	
   // 注册SpringBoot专用的Bean对象
   context.getBeanFactory().registerSingleton("springApplicationArguments",
         applicationArguments);
   if (printedBanner != null) {
      context.getBeanFactory().registerSingleton("springBootBanner", printedBanner);
   }

   // Load the sources。加载资源
   Set<Object> sources = getSources();
   Assert.notEmpty(sources, "Sources must not be empty");
   load(context, sources.toArray(new Object[sources.size()]));
   listeners.contextLoaded(context);
}
```

```java
protected void load(ApplicationContext context, Object[] sources) {
   if (logger.isDebugEnabled()) {
      logger.debug(
            "Loading source " + StringUtils.arrayToCommaDelimitedString(sources));
   }
    //创建BeanDefinitionLoader对象,并设置了Bean的名称生成器，资源加载器，环境变量信息，。加载资源到Reader中。
   BeanDefinitionLoader loader = createBeanDefinitionLoader(
         getBeanDefinitionRegistry(context), sources);
   if (this.beanNameGenerator != null) {
      loader.setBeanNameGenerator(this.beanNameGenerator);
   }
   if (this.resourceLoader != null) {
      loader.setResourceLoader(this.resourceLoader);
   }
   if (this.environment != null) {
      loader.setEnvironment(this.environment);
   }
   loader.load();
}
```

```java
/**
 * Create a new {@link BeanDefinitionLoader} that will load beans into the specified
 * {@link BeanDefinitionRegistry}.
 * @param registry the bean definition registry that will contain the loaded beans
 * @param sources the bean sources
 */
BeanDefinitionLoader(BeanDefinitionRegistry registry, Object... sources) {
   Assert.notNull(registry, "Registry must not be null");
   Assert.notEmpty(sources, "Sources must not be empty");
   this.sources = sources;
   this.annotatedReader = new AnnotatedBeanDefinitionReader(registry);
   this.xmlReader = new XmlBeanDefinitionReader(registry);
   if (isGroovyPresent()) {
      this.groovyReader = new GroovyBeanDefinitionReader(registry);
   }
   this.scanner = new ClassPathBeanDefinitionScanner(registry);
   this.scanner.addExcludeFilter(new ClassExcludeFilter(sources));
}
```

7、刷新，此处为重点内容。

```java
@Override
public void refresh() throws BeansException, IllegalStateException {
   synchronized (this.startupShutdownMonitor) {
      // 刷新回调必要的初始化和验证
      prepareRefresh();

      // 通知子类刷新内部BeanFactory
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // 准备各种类型的Bean工厂
      prepareBeanFactory(beanFactory);

      try {
         // 允许在上下文子类中对bean工厂进行后处理。
         postProcessBeanFactory(beanFactory);

         // 调用已经注册到容器中的处理器
         invokeBeanFactoryPostProcessors(beanFactory);

         // 注册Bean的后置处理器拦截Bean的创建.
         registerBeanPostProcessors(beanFactory);

         // 初始化消息资源，各种国际化资源
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // 在特定的上下文子类中初始化其他特殊bean。
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // 检查监听器bean并注册它们。
         finishBeanFactoryInitialization(beanFactory);

         // 最后一步：发布相应的事件。
         finishRefresh();
      }

      catch (BeansException ex) {
         if (logger.isWarnEnabled()) {
            logger.warn("Exception encountered during context initialization - " +
                  "cancelling refresh attempt: " + ex);
         }

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset 'active' flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      }

      finally {
         // Reset common introspection caches in Spring's core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      }
   }
}
```
prepareBeanFactory
```java
protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
   // Tell the internal bean factory to use the context's class loader etc.
   beanFactory.setBeanClassLoader(getClassLoader());
   beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
   beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

   // Configure the bean factory with context callbacks.
   beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
   beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
   beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
   beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
   beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

   // BeanFactory interface not registered as resolvable type in a plain factory.
   // MessageSource registered (and found for autowiring) as a bean.
   beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
   beanFactory.registerResolvableDependency(ResourceLoader.class, this);
   beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
   beanFactory.registerResolvableDependency(ApplicationContext.class, this);

   // Register early post-processor for detecting inner beans as ApplicationListeners.
   beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

   // Detect a LoadTimeWeaver and prepare for weaving, if found.
   if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
      beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
      // Set a temporary ClassLoader for type matching.
      beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
   }

   // Register default environment beans.
   if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
   }
   if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
   }
}
```













# [DefaultListableBeanFactory](https://www.cnblogs.com/davidwang456/p/4187012.html)